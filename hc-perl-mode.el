;hc-perl-mode.el
;start by M-;

(add-hook 'perl-mode-hook
          '(lambda()
             ;; 	 (cperl-mode)
             (local-set-key [?\M-\;] 'perl-mode-accel)
             (local-set-key "\C-x\C-h" 'perl-mark-this-function)
             (local-set-key "\C-\M-h" 'backward-kill-sexp)
             (local-set-key [?\M-\{] 'perl-jump-to-function-backward)
             (local-set-key [?\M-\}] 'perl-jump-to-function-forward)
             ;; 	 (local-set-key "\C-\M-x" '(lambda()(interactive) (shell-command (buffer-file-name))))
             (local-set-key "\C-\M-x" '(lambda()(interactive) (save-buffer) (shell-command (buffer-file-name))))
             ;; 	 (local-set-key [?\C-\M-\;] '(lambda() (interactive) (relief "#" 3)))
             (local-set-key [?\C-\M-\;] '(lambda() (interactive) (horizontal-bar "#" 62)))
             (local-set-key "\C-xp" 'perl-prototype-declarations)
             (if (= 0 (buffer-size)) (insert-perl-template))
             ))

(add-hook 'cperl-mode-hook
          '(lambda()
             (cperl-toggle-auto-newline)
                                        ;complete-symbol
             ;; 	 (require 'perlplus)
             ;; 	 (perlplus-setup)
             ;; 	 (setq cperl-indent-level 4)
             ;; 	 (local-set-key [?\C-\M-\;] 'perlplus-complete-symbol)
             ))

(defun perl-insert-function ()
  "Insert Perl function."
  (interactive)
  (open-line-and-insert "") (forward-line)
  (open-line-and-insert "sub  {") (forward-line)
  (open-line-and-insert "my () = @_;") (forward-line)
  (open-line-and-insert "") (forward-line)
  (open-line-and-insert "}") (forward-line -3) (end-of-line) (backward-char 2)
  )

(defun perl-prototype-declarations()
  "Generate prototype declarations"
  (interactive)
  ;;   (save-excursion
  (let (start temp (counter 0))
    (beginning-of-line)
    (setq start (point))
    ;; Search for prototype declarations
    (goto-char (point-max))
    (if (and (search-backward "### End of Prototype Declaration ###" nil t)
             (search-backward "### Prototype Declaration ###" nil t))
        (progn
          (next-line 1)
          (beginning-of-line)
          (setq start (point))
          )
      (goto-char start)
      (insert "### Prototype Declaration ###\n")
      (setq start (point))
      (insert "### End of Prototype Declaration ###\n")
      )
    (goto-char (point-max))
    ;; Extract functions
    (while (search-backward-regexp "^#? *sub.*{" nil t)
      (setq temp (point))
      (next-line 1)
      (if (> counter 0)
          (append-next-kill))
      (kill-ring-save (point) temp)
      (setq counter (+ counter 1))
      (previous-line 1)
      )
    ;; Generate prototype declarations
    (goto-char start)
    (yank)
    (goto-char start)
    (while (> counter 0)
      (beginning-of-line)
      (search-forward-regexp "{" nil t)
      (backward-char 1)(insert " ")(forward-char 1)
      (backward-delete-char 1)
      (backward-delete-char-untabify 1)
      (insert ";")
      (next-line 1)
      (setq counter (- counter 1)))
    (beginning-of-line)
    ;; Kill old prototype declarations 
    (setq temp (point))
    (search-forward "### End of Prototype Declaration ###" nil t)
    (beginning-of-line)
    (kill-region temp (point))
    ;; Retrun to the start point of prototype declarations
    (goto-char start)
    )
  )

(defun perl-export-functions()
  "Generate prototype declarations"
  (interactive)
  ;;   (save-excursion
  (let (start temp (counter 0))
    (beginning-of-line)
    (setq start (point))
    ;; Search for prototype declarations
    (goto-char (point-max))
    (if (search-backward "@EXPORT = qw" nil t)
        (progn
          (next-line 1)
          (beginning-of-line)
          (setq start (point)))
      (goto-char start)
      (insert "### Prototype Declaration ###\n")
      (setq start (point))
      (insert "### End of Prototype Declaration ###\n"))
    (goto-char (point-max))
    ;; Extract functions
    (while (search-backward-regexp "^sub.*{" nil t)
      (setq temp (point))
      (next-line 1)
      (if (> counter 0)
          (append-next-kill))
      (kill-ring-save (point) temp)
      (setq counter (+ counter 1))
      (previous-line 1)
      )
    ;; Generate prototype declarations
    (goto-char start)
    (yank)
    (goto-char start)
    (while (> counter 0)
      (beginning-of-line)
      (kill-word 1)
      (search-forward-regexp "{" nil t)
      (backward-char 1)(insert " ")(forward-char 1)
      (backward-delete-char 1)
      (backward-delete-char-untabify 1)
      (next-line 1)
      (setq counter (- counter 1)))
    (beginning-of-line)
    ;; Kill old prototype declarations 
    (setq temp (point))
    (search-forward "### End of Prototype Declaration ###" nil t)
    (beginning-of-line)
    (kill-region temp (point))
    ;; Retrun to the start point of prototype declarations
    (goto-char start)
    )
  )

(defun occur-sub()
  "Extract subroutine definitions using occur."
  (interactive)
  (left-side-window 20)
  (other-window 1)
  (occur "^sub .*{")
  (other-window 1))

(defun insert-perl-template ()
  "Insert Perl template."
  (interactive)
  (open-line-and-insert "#!/usr/bin/perl -w") (forward-line)
  (open-line-and-insert "use strict;") (forward-line)
  (open-line-and-insert "use File::Basename;") (forward-line)
  (open-line-and-insert "use Getopt::Std;") (forward-line)
  (open-line-and-insert "my $PROGRAM = basename $0;") (forward-line)
  (open-line-and-insert "my $USAGE=") (forward-line)
  (open-line 1) (insert "\"Usage: $PROGRAM") (forward-line)
  (open-line 1) (insert "\";") (forward-line)
  (open-line-and-insert "") (forward-line)
  (open-line-and-insert "my %OPT;") (forward-line)
  (open-line-and-insert "getopts('', \\%OPT);") (forward-line)
  (open-line-and-insert "") (forward-line)
  )

(defun make-comment-bar ()
  "Make comment bar."
  (interactive)
  (setq i 0)
  (while (< i 80)
    (insert "#")
    (setq i (+ i 1))
    )
  (newline)
  (insert "### ") (end-of-line)
  (insert " ")
  (while (< (current-column) 80)
    (insert "#")
    )
  (newline)
  (setq i 0)
  (while (< i 80)
    (insert "#")
    (setq i (+ i 1))
    )
  (next-line 1)
  (beginning-of-line)
  ;;       (newline)
  )

(defun perl-mode-accel ()
  "Insert perl statemnts quickly by abbreviations."
  (interactive)
  (message "(#)shebang, (A)rgs, (a)utoflush, (o)pen, (p)rint, (l)oop, (i)f, (w)hile, (f)or, (F)unctions, (s)ub")
  (let ((c (read-char)))
    (cond
     ;; (c)omment
     ((equal c ?c)
      (make-comment-bar)
      )

     ;; (#)shebang
     ((equal c ?#)
      (insert-perl-template)
      )

     ;; (A)rgs
     ((equal c ?A)
      (open-line-and-insert "if (!@ARGV) {") (forward-line)
      (open-line-and-insert "print STDERR $USAGE;") (forward-line)
      (open-line-and-insert "exit 1;") (forward-line)
      (open-line-and-insert "}") (forward-line)
      (open-line-and-insert "my ($) = @ARGV;") (backward-char 10)
      )

     ;; (a)utoflush
     ((equal c ?a)
      (open-line-and-insert "STDOUT->autoflush;") (forward-line)
      )

     ;; (l)oop
     ((equal c ?l)
      (open-line-and-insert "while (<>) {") (forward-line)
      (open-line-and-insert "chomp;") (forward-line)
      (open-line-and-insert "my @f = split(/\\t/, $_);") (forward-line)
      (open-line-and-insert "") (forward-line)
      (open-line-and-insert "}") (forward-line -1) (back-to-indentation)
      )

     ;; (L)oop for filter program
     ((equal c ?L)
      (open-line-and-insert "!@ARGV && -t and die $USAGE;") (forward-line)
      (open-line-and-insert "while (<>) {") (forward-line)
      (open-line-and-insert "chomp;") (forward-line)
      (open-line-and-insert "my @f = split(/\\t/, $_);") (forward-line)
      (open-line-and-insert "") (forward-line)
      (open-line-and-insert "}") (forward-line -1) (back-to-indentation)
      )

     ;; (i)f
     ((equal c ?i)
      (open-line-and-insert "if () {") (forward-line)
      (open-line-and-insert "") (forward-line)
      (open-line-and-insert "}")
      (forward-line -2)(end-of-line)(backward-char 3)
      )

     ;; (e)lse
     ((equal c ?e)
      (unless (equal (buffer-substring (- (point) 1) (point)) " ")
        (insert " "))
      (insert "else {") (forward-line)
      (open-line-and-insert "") (forward-line)
      (open-line-and-insert "}")
      (forward-line -1) (back-to-indentation)
      )

     ;; (I)f
     ((equal c ?I)
      (let (branch startpos)
        (setq startpos (point))
        (open-line-and-insert "if () {") (forward-line)
        (open-line-and-insert "") (forward-line)
        (open-line-and-insert "}")
        ;; (E)lsif
        (while (progn
                 (message "(E)lsif, (e)lse  or  other key")
                 (setq branch (read-char))
                 (equal branch ?E))
          (unless (equal (buffer-substring (- (point) 1) (point)) " ")
            (insert " "))
          (insert "elsif () {") (forward-line)
          (open-line-and-insert "") (forward-line)
          (open-line-and-insert "}")
          )
        ;; else
        (when (equal branch ?e)
          (unless (equal (buffer-substring (- (point) 1) (point)) " ")
            (insert " "))
          (insert "else {") (forward-line)
          (open-line-and-insert "") (forward-line)
          (open-line-and-insert "}")
          )
        (goto-char startpos)(end-of-line)(backward-char 3)
        )
      )

     ;; (w)hile
     ((equal c ?w)
      (open-line-and-insert "while () {") (forward-line)
      (open-line-and-insert "") (forward-line)
      (open-line-and-insert "}")
      (forward-line -2)(end-of-line)(backward-char 3)
      )

     ;; (f)or
     ((equal c ?f)
      ;; (open-line-and-insert "for (=\; \; ) {") (forward-line)
      (open-line-and-insert "for () {") (forward-line)
      (open-line-and-insert "") (forward-line)
      (open-line-and-insert "}") (forward-line -2)
      (back-to-indentation) (forward-char 5)
      (let (i direc)
        (message "a, b, ... , z  or  other key")
        (setq i (char-to-string (read-char)))
        (when (string-match "a" i)
          ;; (delete-char 5)(insert "@")(backward-char 3)(insert " my $")
          (insert "@")(backward-char 3)(insert " my $")
          )
        (when (string-match "[b-z]" i)
          ;; (insert "my $" i)(forward-char 3)(insert "$" i)(forward-char 2)(insert "$" i)(backward-char 8)
          (insert "my $" i "=\; $" i "; $" i)(backward-char 8)
          (message "<, >  or  other key")
          (setq direc (read-char))
          (cond
           ((equal ?< direc)
            (insert "0")(forward-char 4)(insert "<")(forward-char 4)(insert "++")(backward-char 6))
           ((equal ?> direc)
            (forward-char 4)(insert ">=0")(forward-char 4)(insert "--")(backward-char 13))
           )
          ))
      )

     ;; (s)ub
     ((equal c ?s)
      (perl-insert-function)
      )
     
     ;; (p)rint
     ((equal c ?p)
      ;; (perl-prototype-declarations)
      ;; (open-line-and-insert "print , \"\\n\";") (backward-char 7)
      (open-line-and-insert "print \"\\n\";") (backward-char 4)
      )

     ;; (P)rintf
     ((equal c ?P)
      (open-line-and-insert "printf \"\\n\";") (backward-char 4)
      )

     ;; (e)xport functions
     ;; ((equal c ?e)
     ;;  (perl-export-functions)
     ;;  )

     ;; (o)ccur sub
     ;; ((equal c ?o)
     ;;  (occur-sub)
     ;;  )

     ;; (o)pen
     ((equal c ?o)
      (open-line-and-insert "open(, \"\") || die \"$!\";") (forward-line)
      (open-line-and-insert "close();")
      (forward-line -1)(end-of-line)(backward-char 18)
      )

     ;; (F)unctions
     ((equal c ?F)
      (open-line-and-insert "Function")(beginning-of-line)
      (make-comment-bar)
      )
     )))

;; perl-mode useful functions
(defun perl-jump-to-function-forward ()
  (interactive)
  (next-line 1)
  (if (search-forward-regexp "^sub .*{.*" nil t)
      (beginning-of-line)
    (previous-line 1))
  )
(defun perl-jump-to-function-backward ()
  (interactive)
  ;;   (perl-beginning-of-function)
  (search-backward-regexp "^sub .*{.*" nil t)
  )
(defun perl-mark-this-function ()
  (interactive)
  (let (tmp end)
    (setq tmp (point))
    (perl-end-of-function)
    (setq end (point))
    (perl-jump-to-function-backward)
    (previous-line 1)
    (while (looking-at "^#")
      (previous-line 1))
    (if (not (looking-at "^$"))
        (next-line 1))
    ;; If you were in the function,
    (if (and (< (point) tmp)
             (< tmp end))
        (set-mark end)
      (goto-char tmp))
    ))
