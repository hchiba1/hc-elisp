;ruby-mode-accel.el
;start by M-;
(add-hook 'ruby-mode-hook
	  '(lambda()
	     (inf-ruby-keys)
	     (local-set-key [?\M-\;] 'ruby-mode-accel)
	     (local-set-key "\C-\M-n" 'scroll-up-line)
	     (local-set-key "\C-\M-p" 'scroll-down-line)
	     (local-set-key "\C-\M-x" '(lambda()(interactive) (save-buffer) (shell-command (buffer-file-name))))
	     (local-set-key "\C-m" 'ruby-reindent-then-newline-and-indent)
	     ))

(defun insert-statement (arg)
  "Insert a new line with string ARG."
  (interactive "sStatement: ")
  (beginning-of-line)
  (open-line 1)
  (indent-according-to-mode)
  (insert arg)
  (indent-according-to-mode)
  (next-line 1)
  (back-to-indentation)
  )

(defun ruby-mode-accel ()
  "Insert ruby statemnts quickly by abbreviations."
  (interactive)
  (message "(s)hebang, (l)oop for filter program, (o)pt, (i)f, (w)hile, (u)ntil, (f)or, (e)ach, ca(s)e, (d)ef, (c)lass, (p)rint, i(n)itialize")
  (let ((c (read-char)))
    (cond
     ;; (s)hebang
     ((equal c ?s)
      (insert-statement "#!/usr/bin/env ruby")
      (insert-statement "require 'optparse'")
      (insert-statement "parser = OptionParser.new")
      (insert-statement "parser.banner =")
      (open-line 1) (insert "\"Usage: ./#{File.basename($0)}") (next-line 1)
      (insert-statement "\"")
      (insert-statement "parser.on(\"-h\", \"--help\", \"\"){")
      (insert-statement "print USAGE")
      (insert-statement "exit 1")
      (insert-statement "}")
      (insert-statement "begin")
      (insert-statement "parser.parse!")
      (insert-statement "rescue OptionParser::ParseError => err")
      (insert-statement "STDERR.puts err.message")
      (insert-statement "STDERR.puts parser.help")
      (insert-statement "exit 1")
      (insert-statement "end")
      (insert-statement "")
      )

     ;; (l)oop for filter program
     ((equal c ?l)
      (insert-statement "unless FileTest.pipe?(STDIN)")
      (insert-statement "STDERR.puts parser.help")
      (insert-statement "exit 1")
      (insert-statement "end")
      (insert-statement "")
      (insert-statement "STDIN.each{|line|")
      (insert-statement "")
      (insert-statement "}")
      (previous-line 2)(back-to-indentation)
      )
     ((equal c ?l)
      (insert-statement "if ARGV.length==0")
      (insert-statement "puts USAGE")
      (insert-statement "exit 1")
      (insert-statement "end")
      (insert-statement "")
      (insert-statement "while STDIN.gets")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 2)(back-to-indentation)
      )
     ((equal c ?d)
      (insert-statement "def ")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 3)(end-of-line)
      )
     ((equal c ?c)
      (insert-statement "class ")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 3)(end-of-line)
      )
     ((equal c ?p)
      (insert-statement "print(\"\")")
      (previous-line 1)(end-of-line)(backward-char 3)
      )
     ((equal c ?n)
      (insert-statement "def initialize()")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 3)(end-of-line)(backward-char 1)
      )
     ((char-equal c ?i)
      (let (branch startpos)
	(setq startpos (point))
	(insert-statement "if  then")
	(insert-statement "")
	(while (progn
		 (message "els(i)f, (e)lse  or  other key")
		 (setq branch (read-char))
		 (char-equal branch ?i))
	  (insert-statement "elsif")
	  (insert-statement "")
	  )
	(cond
	 ((char-equal branch ?e)
	  (insert-statement "else")
	  (insert-statement "")
	  )
	 )
	(insert-statement "end")
	(goto-char startpos)(end-of-line)(backward-delete-char 5)
	)
      )
     ((char-equal c ?s)
      (let (branch startpos)
	(setq startpos (point))
	(insert-statement "case ")
	(while (progn
		 (message "(w)hen, (e)lse  or  other key")
		 (setq branch (read-char))
		 (char-equal branch ?w))
	  (insert-statement "when ")
	  (insert-statement "")
	  )
	(insert-statement "else")
	(insert-statement "")
	(insert-statement "end")
	(goto-char startpos)(end-of-line)
	)
      )
     ((char-equal c ?w)
      (insert-statement "while do")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 3)(end-of-line)(backward-delete-char 2)
      )
     ((char-equal c ?u)
      (insert-statement "until do")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 3)(end-of-line)(backward-delete-char 2)
      )
     ((char-equal c ?f)
      (insert-statement "for  in  do")
      (insert-statement "")
      (insert-statement "end")
      (previous-line 3)(end-of-line)(backward-delete-char 3)(backward-char 4)
      )
     ((equal c ?e)
      (insert-statement ".each{|elem|")
      (insert-statement "")
      (insert-statement "}")
      (previous-line 3)(end-of-line)(backward-char)(backward-delete-char 4)(back-to-indentation)
      )
     )))
